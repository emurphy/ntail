# Autogenerated from a Treetop grammar. Edits may be lost.


module Formatting
  include Treetop::Runtime

  def root
    @root ||= :format_string
  end

  def _nt_format_string
    start_index = index
    if node_cache[:format_string].has_key?(index)
      cached = node_cache[:format_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_token
      if r2
        r1 = r2
      else
        r3 = _nt_literal
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:format_string][start_index] = r0

    r0
  end

  module Literal0
    def value(log_line, color)
      # context-independent...
      self.text_value
    end
  end

  def _nt_literal
    start_index = index
    if node_cache[:literal].has_key?(index)
      cached = node_cache[:literal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if index < input_length
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(Literal0)
      @index += 1
    else
      terminal_parse_failure("any character")
      r0 = nil
    end

    node_cache[:literal][start_index] = r0

    r0
  end

  def _nt_token
    start_index = index
    if node_cache[:token].has_key?(index)
      cached = node_cache[:token][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_remote_addr
    if r1
      r0 = r1
    else
      r2 = _nt_remote_user
      if r2
        r0 = r2
      else
        r3 = _nt_time_local
        if r3
          r0 = r3
        else
          r4 = _nt_request
          if r4
            r0 = r4
          else
            r5 = _nt_status
            if r5
              r0 = r5
            else
              r6 = _nt_body_bytes_sent
              if r6
                r0 = r6
              else
                r7 = _nt_upstream_response_time
                if r7
                  r0 = r7
                else
                  r8 = _nt_request_time
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_http_referer
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_http_user_agent
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_proxy_addresses
                        if r11
                          r0 = r11
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:token][start_index] = r0

    r0
  end

  module RemoteAddr0
    def value(log_line, color)
      if color && Sickill::Rainbow.enabled
        # 24 = 15 + 9, the extra amount of bytes required for the ANSI escape codes...
        "%24s" % foreground(log_line.remote_address, color)
      else
        "%15s" % log_line.remote_address
      end
    end
  end

  def _nt_remote_addr
    start_index = index
    if node_cache[:remote_addr].has_key?(index)
      cached = node_cache[:remote_addr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%a', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(RemoteAddr0)
      @index += 2
    else
      terminal_parse_failure('%a')
      r0 = nil
    end

    node_cache[:remote_addr][start_index] = r0

    r0
  end

  module RemoteUser0
    def value(log_line, color)
      foreground(log_line.remote_user, color)
    end
  end

  def _nt_remote_user
    start_index = index
    if node_cache[:remote_user].has_key?(index)
      cached = node_cache[:remote_user][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%u', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(RemoteUser0)
      @index += 2
    else
      terminal_parse_failure('%u')
      r0 = nil
    end

    node_cache[:remote_user][start_index] = r0

    r0
  end

  module TimeLocal0
    def value(log_line, color)
      foreground(log_line.to_date_s, color)
    end
  end

  def _nt_time_local
    start_index = index
    if node_cache[:time_local].has_key?(index)
      cached = node_cache[:time_local][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%t', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(TimeLocal0)
      @index += 2
    else
      terminal_parse_failure('%t')
      r0 = nil
    end

    node_cache[:time_local][start_index] = r0

    r0
  end

  module Request0
    def value(log_line, color)
      foreground(log_line.to_request_s, color)
    end
  end

  def _nt_request
    start_index = index
    if node_cache[:request].has_key?(index)
      cached = node_cache[:request][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%r', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Request0)
      @index += 2
    else
      terminal_parse_failure('%r')
      r0 = nil
    end

    node_cache[:request][start_index] = r0

    r0
  end

  module Status0
    def value(log_line, color)
      foreground(log_line.status, color)
    end
  end

  def _nt_status
    start_index = index
    if node_cache[:status].has_key?(index)
      cached = node_cache[:status][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%s', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(Status0)
      @index += 2
    else
      terminal_parse_failure('%s')
      r0 = nil
    end

    node_cache[:status][start_index] = r0

    r0
  end

  module BodyBytesSent0
    def value(log_line, color)
      foreground(log_line.body_bytes_sent, color)
    end
  end

  def _nt_body_bytes_sent
    start_index = index
    if node_cache[:body_bytes_sent].has_key?(index)
      cached = node_cache[:body_bytes_sent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%b', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(BodyBytesSent0)
      @index += 2
    else
      terminal_parse_failure('%b')
      r0 = nil
    end

    node_cache[:body_bytes_sent][start_index] = r0

    r0
  end

  module UpstreamResponseTime0
    def value(log_line, color)
      foreground(log_line.upstream_response_time, color)
    end
  end

  def _nt_upstream_response_time
    start_index = index
    if node_cache[:upstream_response_time].has_key?(index)
      cached = node_cache[:upstream_response_time][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%<T', false, index)
      r0 = instantiate_node(Node,input, index...(index + 3))
      r0.extend(UpstreamResponseTime0)
      @index += 3
    else
      terminal_parse_failure('%<T')
      r0 = nil
    end

    node_cache[:upstream_response_time][start_index] = r0

    r0
  end

  module RequestTime0
    def value(log_line, color)
      foreground(log_line.request_time, color)
    end
  end

  def _nt_request_time
    start_index = index
    if node_cache[:request_time].has_key?(index)
      cached = node_cache[:request_time][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%T', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(RequestTime0)
      @index += 2
    else
      terminal_parse_failure('%T')
      r0 = nil
    end

    node_cache[:request_time][start_index] = r0

    r0
  end

  module HttpReferer0
    def value(log_line, color)
      foreground(log_line.to_referer_s, color)
    end
  end

  def _nt_http_referer
    start_index = index
    if node_cache[:http_referer].has_key?(index)
      cached = node_cache[:http_referer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%R', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(HttpReferer0)
      @index += 2
    else
      terminal_parse_failure('%R')
      r0 = nil
    end

    node_cache[:http_referer][start_index] = r0

    r0
  end

  module HttpUserAgent0
    def value(log_line, color)
      foreground(log_line.to_agent_s, color)
    end
  end

  def _nt_http_user_agent
    start_index = index
    if node_cache[:http_user_agent].has_key?(index)
      cached = node_cache[:http_user_agent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%U', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(HttpUserAgent0)
      @index += 2
    else
      terminal_parse_failure('%U')
      r0 = nil
    end

    node_cache[:http_user_agent][start_index] = r0

    r0
  end

  module ProxyAddresses0
    def value(log_line, color)
      (log_line.proxy_addresses || []).join(", ").foreground(color)
    end
  end

  def _nt_proxy_addresses
    start_index = index
    if node_cache[:proxy_addresses].has_key?(index)
      cached = node_cache[:proxy_addresses][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('%p', false, index)
      r0 = instantiate_node(Node,input, index...(index + 2))
      r0.extend(ProxyAddresses0)
      @index += 2
    else
      terminal_parse_failure('%p')
      r0 = nil
    end

    node_cache[:proxy_addresses][start_index] = r0

    r0
  end

end

class FormattingParser < Treetop::Runtime::CompiledParser
  include Formatting
end


# vim:syntax=ruby
